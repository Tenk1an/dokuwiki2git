#!/usr/bin/env python
# Copyright (c) 2011-2014 Heikki Hokkanen <hoxu at users.sf.net>
# License: AGPLv3
import fnmatch
import logging
import optparse
import os
import shutil
import subprocess
import sys
import time
import urllib.parse

USAGE = """
dokuwiki2git converts dokuwiki data directory into a git repository containing
the wiki pages, with proper history. Thus, migration to git-backed wiki engines
(eg. gollum) becomes easier.

$ dokuwiki2git [options] /path/to/dokuwiki/data"""

logging.basicConfig(level = logging.DEBUG, format = '%(levelname)s - %(message)s')
log = logging.getLogger()
windows = os.name == 'nt'
fileOpenMode = 'rb'

if windows:
	fileOpenMode = 'rt'

class Converter:
	def __init__(self):
		self.datadir = None
		self.atticdir = None
		self.mediadir = None
		self.metadir = None
		self.changelog = [] # (timestamp, ip, changetype, pagename, author, comment)
		self.commands = [] # commands to run to create the git repository
		self.createdDirs = set()
		self.gitdir = 'gitdir'
		self.users = {}
		self.extension = '.txt'
		self.convert = None
		self.verbose = False

	def create_git_repository(self):
		log.info('Creating git repository')
		os.mkdir(self.gitdir)

		totalCommands = len(self.commands)
		runCommands = 0

		# run all commands
		for command in self.commands:
			command.execute();
			
			runCommands += 1
			if not self.verbose:
				print('', end=f'\rCommands done {runCommands} / {totalCommands}')


	def get_pagepath_and_timestamp(self, filename):
		filename = os.path.relpath(filename, self.atticdir)
		parts = filename.rsplit('.', 3)
		return parts[0], parts[1] # pagepath, filename

	def add_created_dir(self, dirname: str):
		self.createdDirs.add(dirname)
		parts = dirname.rsplit(os.sep, 1)
		while len(parts) > 1:
			self.createdDirs.add(parts[0])
			parts = parts[0].rsplit(os.sep, 1)
	
	def append_call(self, cmd, outputfile: str=None, shell=False, ignore_exit=False):
		self.commands.append(CallCommand(cmd, self.gitdir, outputfile, shell, ignore_exit))
	
	def append_command(self, command):
		self.commands.append(command)

	def append_delete_commands(self, pagefile: str):
		if windows:
			# delete, leaving directories in place
			self.append_call(['git', 'rm', '--cached', '--quiet', pagefile], ignore_exit=True)
			targetpath = os.path.join(self.gitdir, pagefile)
			self.append_command(DelFileCommand(targetpath))
		else:
			self.append_call(['git', 'rm', '--quiet', '--', pagefile], ignore_exit=True)

	def append_update_commands(self, pagefile: str, filename: str):
		self.append_directory_create_commands(pagefile)
		
		if windows:
			targetpath = os.path.join(self.gitdir, pagefile)
			self.append_command(UnzipFileCommand(filename, targetpath, self.convert or False))
			# self.append_call(['7z', 'x', '-aoa', '-so', filename], outputfile=pagefile)
		else:
			self.append_call(['gunzip', '-c', filename], outputfile=pagefile)

		if self.convert:
			self.append_call(['pandoc', '-f', 'dokuwiki', '-t', self.convert, '-o', pagefile, pagefile], ignore_exit=True)
		self.append_call(['git', 'add', '--force', '--', pagefile])

	def append_media_copy_commands(self, sourcepath: str, targetfile: str):
		self.append_directory_create_commands(targetfile)
		targetpath = os.path.join(self.gitdir, targetfile)
		self.append_command(CopyFileCommand(sourcepath, targetpath))
		self.append_call(['git', 'add', '--force', '--', targetfile])

	def append_directory_create_commands(self, pagefile: str):
		dirname = os.path.dirname(pagefile)
		
		if len(dirname) > 0:
			fulldir = os.path.join(self.gitdir, dirname)
			self.append_command(MakeDirCommand(fulldir))

	def append_commit_command(self, author: str, timestamp: str, message: str):
		self.append_call(['git', 'commit', '--quiet', '--allow-empty', '--author={}'.format(author), '--date={} +0000'.format(timestamp), '-m', message], ignore_exit=True)

	def has_changelog_entry(self, pagepath, timestamp):
		for c in self.changelog:
			ts = c[0]
			pagename = c[3]
			if timestamp == ts and pagepath == pagename.replace(':', os.sep):
				return
		log.warn('Attic contains "%s" timestamp %s, but is not referenced by changelog, skipping. Please report this!' % (pagepath, timestamp))

	def read_attic(self):
		log.info('Reading attic')

		# Check that all referenced pages exist in attic
		for c in self.changelog:
			pagepath = c[3].replace(':', os.sep)
			filename = os.path.join(self.atticdir, pagepath + '.%s.txt.gz' % c[0])
			if not os.path.exists(filename):
				log.warn('File "%s" does not exist, despite being in changelog, skipping' % filename)
				continue

			# depending on type of change, either add or remove
			pagepath, timestamp = self.get_pagepath_and_timestamp(filename)
			pagefile = pagepath + self.extension
			message = pagepath + ': ' + c[5]
			user = c[4]
			email = 'dokuwiki@%s' % (c[1])
			if len(user) == 0:
				user = 'dokuwiki2git'
			elif user in self.users:
				email = self.users[user]['email']
				user = self.users[user]['name']
			author = '%s <%s>' % (user, email)
			cmdCount = len(self.commands)
			
			if c[2] in ('C', 'E', 'e', 'R'): # create, edit, minor edit, restore
				self.append_update_commands(pagefile, filename)
			elif c[2] == 'D': # delete
				self.append_delete_commands(pagefile)

			if len(self.commands) > cmdCount:
				self.append_commit_command(author, timestamp, message)

		# check that all pages in attic have a matching changelog entry
		for path, dirs, files in os.walk(self.atticdir):
			for f in files:
				if fnmatch.fnmatch(f, '*.txt.gz'):
					filename = os.path.join(path, f)
					pagepath, timestamp = self.get_pagepath_and_timestamp(filename)
					self.has_changelog_entry(pagepath, timestamp)

	def read_data(self):
		self.append_call(['git', 'init', '--quiet'])
		self.append_call(['git', 'config', 'core.safecrlf', 'false'])
		# find user Real Name and email
		self.read_user_data()
		# go through data/meta
		self.read_meta()
		# sort history
		self.changelog.sort()
		# go through data/attic, importing pages referenced by .changes in meta
		self.read_attic()
		self.read_media()
		self.append_call(['git', 'commit', '--quiet', '--allow-empty', '--author=dokuwiki2git <dokuwiki2git@hoxu.github.com>', '-m', 'Dokuwiki data imported by dokuwiki2git'])

	def read_media(self):
		log.info('Reading media')
		for path, dirs, files in os.walk(self.mediadir):
			for f in files:
				sourcefile = os.path.join(path, f)
				targetfile = os.path.relpath(sourcefile, self.datadir)
				self.append_media_copy_commands(sourcefile, targetfile)
		self.append_call(['git', 'commit', '--quiet', '--allow-empty', '--author=dokuwiki2git <dokuwiki2git@hoxu.github.com>', '-m', 'Import media files'])

	def read_meta(self):
		log.info('Reading meta')
		pages = 0
		for path, dirs, files in os.walk(self.metadir):
			for f in files:
				if fnmatch.fnmatch(f, '*.changes'):
					relpath = os.path.relpath(os.path.join(path, f), self.metadir)
					pagepath = relpath.rsplit('.', 1)[0]
					self.read_meta_page(pagepath, os.path.join(path, f))
					pages += 1
		log.info('%d changelog entries for %d pages found' % (len(self.changelog), pages))

	def read_meta_page(self, pagepath, fullpath):
		if pagepath in ('_dokuwiki', '_comments', '_media'):
			return
		pagename = pagepath.replace(os.sep, ':')
		log.debug('Reading meta for page "%s"' % pagename)
		with open(fullpath, fileOpenMode, encoding='utf-8') as f:
			for line in f:
				changeparts = line.split('\t')
				if len(changeparts) == 8:
					del changeparts[7]
				log.debug(changeparts)
				assert(len(changeparts) == 7)
				assert(changeparts[3] == urllib.parse.unquote(pagename))
				changeparts[3] = pagename
				assert(changeparts[2] in ('C', 'D', 'E', 'e', 'R')) # create, delete, edit, minor edit, restore
				self.changelog.append(changeparts)

	def read_user_data(self):
		log.info('Reading users.auth.php')
		parentdir = os.path.abspath(os.path.join(self.datadir, os.pardir))
		users_file = os.path.join(parentdir, 'conf', 'users.auth.php')
		with open(users_file, fileOpenMode, encoding='utf-8') as f:
			for line in f:
				if not line.startswith("#") and len(line) > 1:
					userparts = line.split(':')
					assert(len(userparts) == 5)
					log.debug(userparts)
					self.users[userparts[0]] = {'name' : userparts[2], 'email': userparts[3]}
		log.info('Read %d users' % len(self.users))

	def run(self, params):
		parser = optparse.OptionParser(usage = USAGE)
		parser.add_option('-o', '--output', dest='outputdir', help='Create git directory at outputdir. Default is "gitdir"', default = 'gitdir')
		parser.add_option('-q', '--quiet', action='store_const', const=0, dest='verbose', help='Show only warnings and errors')
		parser.add_option('-e', '--extension', action='store', dest='extension', default=".txt", help='Output file extension for pages (default: ".txt")')
		parser.add_option('-c', '--convert', action='store', dest='convert', help='Convert output to this format using pandoc (default: None)')
		parser.add_option('-v', '--verbose', action='store_const', const=2, dest='verbose', help='Show debug messages', default=1)
		(options, args) = parser.parse_args(params)
		level = logging.WARN
		if options.verbose:
			level = (logging.WARN, logging.INFO, logging.DEBUG)[options.verbose]
		log.setLevel(level)
		if level == logging.DEBUG:
			self.verbose = True
		self.gitdir = options.outputdir
		self.extension = options.extension
		self.convert = options.convert

		time_start = time.time()
		if len(args) == 0:
			parser.print_help()
			log.error('Dokuwiki data directory is a required argument')
			sys.exit(1)
		self.set_datadir(args[0])
		self.read_data()
		log.info('%d commands queued to be executed' % len(self.commands))
		self.create_git_repository()
		time_end = time.time()
		time_took = time_end - time_start
		log.info('Finished converting dokuwiki data dir "%s" into a git repository "%s", took %.2f seconds' % (self.datadir, self.gitdir, time_took))

	def set_datadir(self, datadir):
		if not os.path.isfile(os.path.join(datadir, '_dummy')):
			raise RuntimeError('Directory "%s" does not look like a dokuwiki datadir' % datadir)
		self.datadir = os.path.abspath(datadir)
		self.metadir = os.path.join(self.datadir, 'meta')
		self.atticdir = os.path.join(self.datadir, 'attic')
		self.mediadir = os.path.join(self.datadir, 'media')
		log.info('Using datadir: %s' % self.datadir)

class MakeDirCommand:
	def __init__(self, dirname: str):
		self.dirname = dirname
	
	def execute(self):
		if not os.path.exists(self.dirname):
			log.debug('Creating directory: %s' % self.dirname)
			os.makedirs(self.dirname, exist_ok=True)

class DelFileCommand:
	def __init__(self, filepath: str):
		self.filepath = filepath
	
	def execute(self):
		log.debug('Deleting file: %s' % self.filepath)
		os.remove(self.filepath)

class CopyFileCommand:
	def __init__(self, sourcepath: str, targetpath: str):
		self.sourcepath = sourcepath
		self.targetpath = targetpath
	
	def execute(self):
		log.debug('Copying file: %s' % self.sourcepath)
		shutil.copy2(self.sourcepath, self.targetpath)

class UnzipFileCommand:
	def __init__(self, sourcepath: str, targetpath: str, clean=False):
		self.sourcepath = sourcepath
		self.targetpath = targetpath
		self.clean = clean
	
	def execute(self):
		cmd = ['7z', 'x', '-aoa', '-sccUTF-8', '-so', self.sourcepath]
		try:
			with open(self.targetpath, mode='w+t', encoding='utf-8') as f:
				# with subprocess.Popen(cmd, stdout=subprocess.PIPE) as unzip:
				# 	output = unzip.communicate()
				# 	for line in output[0].decode('utf-8').splitlines():
				with subprocess.Popen(cmd, stdout=subprocess.PIPE, encoding='utf-8') as unzip:
					for line in unzip.stdout:
						# There seems to be a bug in pandoc's table handling where a preceding line
						# with just '\\' on it can make table headers on next line fail
						if self.clean and line.strip() == '\\\\':
							f.write('')
						else:
							f.write(line)

				if unzip.returncode != 0:
					raise RuntimeError('Unzip of %s failedCommand "%s" failed' % cmd)
		except Exception as e:
			log.error("Unzipping %s failed" % self.sourcepath)
			raise e

class CallCommand:
	def __init__(self, cmd, gitdir, outputfile: str=None, shell=False, ignore_exit=False):
		self.cmd = cmd
		self.gitdir = gitdir
		self.outputfile = outputfile
		self.shell = shell or False
		self.ignore_exit = ignore_exit or False
	
	def execute(self):
		log.debug('CMD: %s' % self.cmd)
		if self.outputfile:
			with open(os.path.join(self.gitdir, self.outputfile), mode='w+b') as f:
				ret = subprocess.call(self.cmd, stdout=f, cwd=self.gitdir, shell=self.shell)
		else:
			ret = subprocess.call(self.cmd, cwd=self.gitdir, shell=self.shell)

		if ret != 0 and not self.ignore_exit:
			raise RuntimeError('Command "%s" failed' % self.cmd)

if __name__ == '__main__':
	c = Converter()
	c.run(sys.argv[1:])
